---
title: "Geocode2019"
author: "Alan Jackson"
date: "January 7, 2019"
output: html_document
---

```{r setup, include=FALSE}

library(tidyverse)
library(stringr)
library(dplyr)

options(stringsAsFactors = FALSE)

HoustonBoundary <- c(-95.789963, 29.518566, -95.005814, 30.117875)

reclean <- c("District1aReCleanData.rds", 
             "District2aReCleanData.rds")
recleanpath <- "~/Dropbox/CrimeStats/"

dflist <- vector(mode = "list", length = 2)
for (i in 1:2) {
    dflist[[i]] <- as.tibble(readRDS(paste0(recleanpath, reclean[i])))
}

BeatToZip <- as.tibble(readRDS("~/Rprojects/CrimeStats/BeatToZip.rds"))

source("Edit_Addresses.R") # load in address edits

knitr::opts_chunk$set(echo = TRUE)
```

```{r define functions}

#     Create dictionary data frame of pattern/replacement
Makedict <- function(dictionary) {
  dict <- cbind.data.frame(split(dictionary, rep(1:2, times=length(dictionary)/2)), stringsAsFactors=F)
  names(dict) <- c("From", "To")
  return(dict)
}

#   test the searches first to see what they will find
testregex <- function(dframe, col, pat) { # input data frame and regex
  for(i in 1:length(pat[,1])) {
    print(paste("Pattern: ",pat[i,1]))
    hits <- unique(dframe[[col]][grepl(pat[i,1],dframe[[col]])])
    if (length(hits)>0){
      print(paste("   Result: ", hits))
    }
    else {
      print("No hits")
    }
  }
}

#   apply to input array
applyregex <- function(dframe, col, pat) {
  for(i in 1:length(pat[,1])) {
  dframe[[col]] <- str_replace_all(dframe[[col]],pat[i,1],pat[i,2])
  }
  return(dframe)
}

#   Following is sample of how to apply

#  dictionary <- c(
#                  " *P*O* BOX\\s\\d* *","",
#                  " *BOX\\s\\d* *","",
#                  "P *O BX",""
#  )
#  dict <- Makedict(dictionary)
#  #   test them first
#  testregex(df2, "Street", dict)
#  #   Apply
#  df2 <- applyregex(df2, "Street", dict)

```


Call sequence is

* address (required): street number and street name (1234 N Main ST)
* city (optional): City name. If both city and zip are given, they may conflict.
* state (optional): State 2-letter postal abbreviation
* zip (optional): 5 digit US Postal Zipcode

Either city and state, or zip is required

Will return the last match if there are multiple matches. That way downtown Houston will not show up as "Clutch City".

Returns will be:

* status code: 
  + "success"=success 
  + "multiples"=success but multiple answers
  + "partial match"=success but not a 100% match with input address 
  + "fail"=fail
* matching address
* lat
* long
* tract
* block

```{r census geocoder}

###############################################################
#############   GetResult
###############################################################
GetResult <- function(urlreq) {
  #  required libraries 
  
  require(httr)
  
  #   set up to retry twice on server type error (which usually works)
  attempt <- 1
  result <- data.frame(status_code=0)
  while(result$status_code!=200 && attempt<=3 ) {
    if (attempt>1){print(paste("attempted", attempt))}
    attempt <- attempt + 1
    try(
      #     Go get result
      result <- httr::GET(urlreq)
    )
  }
  return(result)
}
###############################################################
#############   Census_decoder
###############################################################
Census_decoder <- function(address, city=NA, state=NA, zip=NA){
  
  urlreq <- paste0("https://geocoding.geo.census.gov/geocoder/geographies/address?street=",gsub(" ", "+",address))
  if (!is.na(city)){urlreq <- paste0(urlreq,"&city=", city)}
  if (!is.na(state)){urlreq <- paste0(urlreq,"&state=", state)}
  if (!is.na(zip)){urlreq <- paste0(urlreq,"&zip=", zip)}
  urlreq <- paste0(urlreq,"&benchmark=Public_AR_Current&vintage=Current_Current&format=json")
  
  print(urlreq)
  result <- GetResult(urlreq)
  #     did we succeed?
  if (result$status_code != 200) { # failure
    return(data.frame(
      status=paste("fail_code: ",result$status_code),
      match_address=NA,
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  } else {
  result <- httr::content(result)
  Num_matches <- length(result[["result"]][["addressMatches"]])
  
  if (Num_matches <= 0) { # failed to find address
    return(data.frame(
      status="fail_length",
      match_address=NA,
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  }
    
    # pick matching result if multiples offered
  for (i in 1:Num_matches) {
    temp <- result[["result"]][["addressMatches"]][[i]]
    if (grepl(address, 
        str_split(temp[["matchedAddress"]], ",")[1])) { break }
  }
    tract <- temp[["geographies"]][[
                   "2010 Census Blocks"]][[1]][["TRACT"]]
    if (is.null(tract)){
      return(data.frame(
        status="fail_tract",
        match_address=NA,
        lat=NA,
        long=NA,
        tract=NA,
        block=NA
      ))
    }
    status <- "success"
    match_address=temp[["matchedAddress"]] 
    lat=temp[["coordinates"]][["y"]]
    long=temp[["coordinates"]][["x"]]
    tract=temp[["geographies"]] [[
                "2010 Census Blocks"]][[1]][["TRACT"]]
    block=temp[["geographies"]] [[
                "2010 Census Blocks"]][[1]][["BLOCK"]]
    
    return(data.frame(
      status=status,
      match_address=match_address,
      lat=lat,
      long=long,
      tract= tract,
      block=block
    ))
  } # end if/else
}
```

## Prep data

1. reduce to unique addresses
2. apply edits


```{r prep data}

# Read in clean data files

df <- dplyr::bind_rows(dflist)


  # create address in df: 
  # Block_Range + Suffix + Street + Type + ", Houston, TX"

df$Address <- paste(df$Block_Range, df$Suffix, df$Street, df$Type, ", Houston, TX")
df$Address <- str_replace_all(df$Address, "- ", "")
df$Address <- str_replace_all(df$Address, "  ", " ")

# flag records not matchable

df <- df %>% 
  mutate(geocode_status=case_when(
    grepl("^UNK", Block_Range) ~ "not possible",
    grepl(" NA ", Address)     ~ "not possible",
    grepl("^UNK ", Address)    ~ "not possible",
    TRUE                       ~ "pending"
      )
    )

# Apply edits to Address field

# Make a list of unique addresses and beats for pending and count

unmatched <- df %>%
  filter(geocode_status=="pending") %>%
  add_count(Address, Beat) %>% 
  select(Address, Beat, n, geocode_status) %>%  
  distinct() %>% 
  arrange(-n) # focus on most important first

# edit addresses

dict <- Makedict(dictionary)
#   test them first
testregex(unmatched, "Address", dict)
#   Apply
unmatched <- applyregex(unmatched, "Address", dict)

# Puff up unmatched with empty columns

unmatched <- 
  unmatched %>% 
  mutate(match_address=NA,
         lat=NA,
         long=NA,
         tract=NA,
         block=NA,
         status=NA )

```

##  Census Geocoding

Call census geocoder for first and last address, and on success
average the two answers and add in the lat long values as well as other good stuff.

```{r do geocoding}

###############################################################
#############   getlatlong
###############################################################
getlatlong <- function(addr, beat, newaddr){
  x <- unlist(strsplit(unlist(addr), ","))
  city <- trimws(x[2])
  state <- trimws(x[3])
  adr <- unlist(strsplit(str_extract(x[1], "^[0-9]+-[0-9]+"),"-"))[1]
  adr <- str_replace(adr, "00$", newaddr)
  adr <- str_replace(adr, "^0$", newaddr)
  street <- trimws(sub("^[0-9]+-[0-9]+", "", x[1]))
  
  # Pull list of potential zipcodes
  
  ziplist <- BeatToZip[BeatToZip$beat==beat,][2]
  
  # try the various potential zipcodes
  
  keepzip <- NA
  for (zip in unlist(ziplist)) {
    loc <- Census_decoder(paste(adr, street), city, state, zip)
    if (loc[1] != "success"){ # try across the street
      adrplus <- as.character(as.numeric(adr)+1)
      loc <- Census_decoder(paste(adrplus, street), city, state, zip)
    }
    if (loc[1] == "success") {
        # does the street match?
        x <- unlist(strsplit(loc$match_address, ","))
        newstreet <- trimws(sub("^[0-9]+", "", x[1]))
        if (grepl(street, newstreet)) {
          #   sometimes it returns a new zip. Accept the new one.
          keepzip <- x[4]
          
          break # success - break out of loop
        }
    }
  }
  
  # if we couldn't get this test to succeed, then give up.
  
  if (is.na(keepzip)) {
    print("===========")
    print("zip failure")
    print("===========")
    return(data.frame(
      status="fail on zip",
      match_address=x[1],
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  }

  #   return data
  
  return(data.frame(
    status="success",
    match_address=loc$match_address,
    lat=loc[3],
    long=loc[4],
    tract=loc[5],
    block=loc[6]
  ))
  
}

```

```{r Do geocoding}

#####################################
##    spin through data geocoding
#####################################

begin <- 1
#for (i in begin:nrow(unmatched)) {
for (i in begin:(begin+999)) {
#for (i in 572:572) {
  print(paste("--->",i,unmatched[i,1]))
  newaddr <- "30"
  if (grepl("FWY", unmatched[i,]$Address)){newaddr <- "15"}
  latlong <- getlatlong(unmatched[i,]$Address, unmatched[i,]$Beat, newaddr)
  if (latlong$status=="success") {
    #print(paste("=======final=======",latlong[1,]))
    unmatched[i,]$match_address  <- latlong$match_address
    unmatched[i,]$lat            <- latlong$lat
    unmatched[i,]$long           <- latlong$long
    unmatched[i,]$tract          <- latlong$tract
    unmatched[i,]$block          <- latlong$block
    unmatched[i,]$geocode_status <- "census"
    unmatched[i,]$status         <- latlong$status
  } else {
    unmatched[i,]$geocode_status <- "census fail"
    unmatched[i,]$status         <- latlong$status
  }
}

saveRDS(unmatched, "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

```


---- census errors (they want the wrong name)

W DALLAS ST   -> W DALLAS AVE
MID LN        -> MID LANE DR


```{r do some stats}

#   Percent of unique addresses found, and percent of total found

unmatched %>% 
  group_by(status) %>% 
  summarise(n=n())

# re-edit addresses

unmatched <- readRDS( "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

source("Edit_Addresses.R") # load in address edits

dict <- Makedict(dictionary)
#   test them first
testregex(unmatched, "Address", dict)
#   Apply
unmatched <- applyregex(unmatched, "Address", dict)

#    special cases - digits replace last 2 on address
special <- tribble(
  ~match, ~addr,
  "GREENWAY PLAZA DR", "03",
  "IRVINGTON BLVD",    "05",
  "CUMMINS ST",        "15",
  "VERNON ST",         "15",
  "EAST",              "41",
  "CETTIPARK ST",      "10"
)

# Skip these, census won't get them, this will speed things up

skips <- c("MEMORIAL", "SAWYER", "S HEIGHTS", "FWY", "PICNIC", "HOMELESS", "PO BOX", "POBOX","WASHINGTON", "HAYS", "POST OAK")

##########################################
##    second spin through data geocoding
##########################################


begin <- 2200
for (i in begin:nrow(unmatched)) {
#for (i in begin:(begin+999)) {
#for (i in 572:572) {
  if (unmatched[i,]$status!="success"){ # only the redo's
    # skip hopeless cases
    if (any(str_detect(unmatched[i,]$Address, skips))){next()}
    print(paste("--->",i,unmatched[i,1]))
    # Did I already succeed at this match somewhere?
    a <- unmatched %>% filter(Address == unmatched[i,]$Address,
                              status=="success" )
    if (nrow(a)>0){
      unmatched[i,4:10] <- a[1,4:10]
      print("found previous match")
      next
    }
    newaddr <- "30"
    #special[grep(unmatched[i,1], special$match), ]
    if (grepl("FWY", unmatched[i,]$Address)){newaddr <- "15"}
    if(any(str_detect(unmatched[i,]$Address, special$match))){
      newaddr <- special[str_detect(unmatched[i,]$Address, special$match),]$addr
    }
    
    latlong <- getlatlong(unmatched[i,]$Address, unmatched[i,]$Beat, newaddr)
    if (latlong$status=="success") {
      #print(paste("=======final=======",latlong[1,]))
      unmatched[i,]$match_address  <- latlong$match_address
      unmatched[i,]$lat            <- latlong$lat
      unmatched[i,]$long           <- latlong$long
      unmatched[i,]$tract          <- latlong$tract
      unmatched[i,]$block          <- latlong$block
      unmatched[i,]$geocode_status <- "census"
      unmatched[i,]$status         <- latlong$status
    } else {
      unmatched[i,]$geocode_status <- "census fail"
      unmatched[i,]$status         <- latlong$status
    }
  }
}

saveRDS(unmatched, "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

```

