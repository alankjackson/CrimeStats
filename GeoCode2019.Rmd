---
title: "Geocode2019"
author: "Alan Jackson"
date: "January 7, 2019"
output: html_document
---

```{r setup, include=FALSE}

library(data.table)
library(tidyverse)
library(stringr)
library(dplyr)
library(ggmap)
library(lubridate)

options(stringsAsFactors = FALSE)

apikey <- readRDS("~/Dropbox/CrimeStats/apikey.rds")
register_google(key = apikey)

HoustonBdy <- c(-95.789963, 29.518566, -95.005814, 30.117875)
BoundBox <- "bounds=29.518566,-95.789963|30.117875,-95.005814"

reclean <- c("District20gReCleanData.rds" 
             )
recleanpath <- "~/Dropbox/CrimeStats/"

dflist <- vector(mode = "list", length = 2)
for (i in 1:1) {
    dflist[[i]] <- as.tibble(readRDS(paste0(recleanpath, reclean[i])))
}

BeatToZip <- as.tibble(readRDS("~/Rprojects/CrimeStats/BeatToZip.rds"))

knitr::opts_chunk$set(echo = TRUE)
```

```{r define functions}

#     Create dictionary data frame of pattern/replacement
Makedict <- function(dictionary) {
  dict <- cbind.data.frame(split(dictionary, rep(1:2, times=length(dictionary)/2)), stringsAsFactors=F)
  names(dict) <- c("From", "To")
  return(dict)
}

#   test the searches first to see what they will find
testregex <- function(dframe, col, pat) { # input data frame and regex
  for(i in 1:length(pat[,1])) {
    print(paste("Pattern: ",pat[i,1]))
    hits <- unique(dframe[[col]][grepl(pat[i,1],dframe[[col]])])
    if (length(hits)>0){
      print(paste("   Result: ", hits))
    }
    else {
      print("No hits")
    }
  }
}

#   apply to input array
applyregex <- function(dframe, col, pat) {
  for(i in 1:length(pat[,1])) {
  dframe[[col]] <- str_replace_all(dframe[[col]],pat[i,1],pat[i,2])
  }
  return(dframe)
}

#   Following is sample of how to apply

#  dictionary <- c(
#                  " *P*O* BOX\\s\\d* *","",
#                  " *BOX\\s\\d* *","",
#                  "P *O BX",""
#  )
#  dict <- Makedict(dictionary)
#  #   test them first
#  testregex(df2, "Street", dict)
#  #   Apply
#  df2 <- applyregex(df2, "Street", dict)

```


Call sequence is

* address (required): street number and street name (1234 N Main ST)
* city (optional): City name. If both city and zip are given, they may conflict.
* state (optional): State 2-letter postal abbreviation
* zip (optional): 5 digit US Postal Zipcode

Either city and state, or zip is required

Will return the last match if there are multiple matches. That way downtown Houston will not show up as "Clutch City".

Returns will be:

* status code: 
  + "success"=success 
  + "multiples"=success but multiple answers
  + "partial match"=success but not a 100% match with input address 
  + "fail"=fail
* matching address
* lat
* long
* tract
* block

```{r census geocoder}

###############################################################
#############   GetResult
###############################################################
GetResult <- function(urlreq) {
  #  required libraries 
  
  require(httr)
  
  #   set up to retry twice on server type error (which usually works)
  attempt <- 1
  result <- data.frame(status_code=0)
  while(result$status_code!=200 && attempt<=3 ) {
    if (attempt>1){print(paste("attempted", attempt))}
    attempt <- attempt + 1
    try(
      #     Go get result
      result <- httr::GET(urlreq)
    )
  }
  return(result)
}
###############################################################
#############   Census_decoder
###############################################################
Census_decoder <- function(address, city=NA, state=NA, zip=NA){
  
  urlreq <- paste0("https://geocoding.geo.census.gov/geocoder/geographies/address?street=",gsub(" ", "+",address))
  if (!is.na(city)){urlreq <- paste0(urlreq,"&city=", city)}
  if (!is.na(state)){urlreq <- paste0(urlreq,"&state=", state)}
  if (!is.na(zip)){urlreq <- paste0(urlreq,"&zip=", zip)}
  urlreq <- paste0(urlreq,"&benchmark=Public_AR_Current&vintage=Current_Current&format=json")
  
  print(urlreq)
  result <- GetResult(urlreq)
  #     did we succeed?
  if (result$status_code != 200) { # failure
    return(data.frame(
      status=paste("fail_code: ",result$status_code),
      match_address=NA,
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  } else {
  result <- httr::content(result)
  Num_matches <- length(result[["result"]][["addressMatches"]])
  
  if (Num_matches <= 0) { # failed to find address
    return(data.frame(
      status="fail_length",
      match_address=NA,
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  }
    
    # pick matching result if multiples offered
  for (i in 1:Num_matches) {
    temp <- result[["result"]][["addressMatches"]][[i]]
    if (grepl(address, 
        str_split(temp[["matchedAddress"]], ",")[1])) { break }
  }
    tract <- temp[["geographies"]][[
                   "2010 Census Blocks"]][[1]][["TRACT"]]
    if (is.null(tract)){
      return(data.frame(
        status="fail_tract",
        match_address=NA,
        lat=NA,
        long=NA,
        tract=NA,
        block=NA
      ))
    }
    status <- "success"
    match_address=temp[["matchedAddress"]] 
    lat=temp[["coordinates"]][["y"]]
    long=temp[["coordinates"]][["x"]]
    tract=temp[["geographies"]] [[
                "2010 Census Blocks"]][[1]][["TRACT"]]
    block=temp[["geographies"]] [[
                "2010 Census Blocks"]][[1]][["BLOCK"]]
    
    return(data.frame(
      status=status,
      match_address=match_address,
      lat=lat,
      long=long,
      tract= tract,
      block=block
    ))
  } # end if/else
}
```

## Prep data

1. reduce to unique addresses
2. apply edits


```{r prep data}

# Read in clean data files

df <- dplyr::bind_rows(dflist)


  # create address in df: 
  # Block_Range + Suffix + Street + Type + ", Houston, TX"

df$Address <- paste(df$Block_Range, df$Suffix, df$Street, df$Type, ", Houston, TX")
df$Address <- str_replace_all(df$Address, "- ", "")
df$Address <- str_replace_all(df$Address, "  ", " ")

# flag records not matchable

df <- df %>% 
  mutate(geocode_status=case_when(
    grepl("^UNK", Block_Range) ~ "not possible",
    grepl(" NA ", Address)     ~ "not possible",
    grepl("^UNK ", Address)    ~ "not possible",
    TRUE                       ~ "pending"
      )
    )

# Apply edits to Address field

# Make a list of unique addresses and beats for pending and count

unmatched <- df %>%
  filter(geocode_status=="pending") %>%
  mutate(RawAddress=Address) %>% 
  add_count(Address, Beat) %>% 
  select(RawAddress, Address, Beat, n, geocode_status) %>%  
  distinct() %>% 
  arrange(-n) # focus on most important first

# Puff up unmatched with empty columns

unmatched <- 
  unmatched %>% 
  mutate(match_address=NA,
         lat=NA,
         long=NA,
         tract=NA,
         block=NA,
         status="pending",
         GType=NA)

```

##   Street name cleanup functions

```{r cleanup functions}

# address of form [0-9]+ [NSEW] name suffix , city, state, zip, USA
getstreet <- function(address) {
  x <- unlist(strsplit(unlist(address), ","))
  street <- trimws(sub("^[0-9]+", "", x[1]))
  return(street)
}

# address of form [0-9]+-[0-9]+ [NSEW] name suffix , city, state, zip, USA
getoldstreet <- function(address) {
  x <- unlist(strsplit(unlist(address), ","))
  street <- trimws(sub("^[0-9]+-[0-9]+", "", x[1]))
  return(street)
}

# pull final string off street and test if is a valid suffix
getsuffix <- function(street) {
  suffixes <- c("FWY", "CIR", "ST", "RD", "DR", "AVE", "LN", "BLVD",
               "PL", "CT", "PKWY", "TER", "LNDG", "WAY", "TRL",
               "FREEWAY", "CIRCLE", "STREET", "ROAD", "DRIVE",
               "AVENUE", "LANE", "BOULEVARD", "PLACE", "COURT", "PARKWAY",
               "TERRACE", "LANDING", "WAY", "TRAIL")
  suffix <- tail(unlist(strsplit(street,split=" ")),1)
  if (any(suffix==suffixes)) {
    return(suffix)
  } else {return(" ")}
}

```

##  create a file for checking suffixes

```{r suffixes}

# pull out good matched addresses

addresses <- unmatched %>% filter(geocode_status=="census" |
                                  geocode_status=="google") %>% 
                   select(match_address) %>% 
                   mutate(match_address=toupper(match_address)) %>% 
                   unique() 
#   strip out the street names
streets <- addresses$match_address %>% map(getstreet) %>% unique()
streets <- enframe(unlist(streets),value="street")

#   separate street name from suffix
street_stds <- streets %>% #  standard names and suffixes
            rowwise() %>% 
            mutate(suffix=getsuffix(street)) %>% 
            mutate(street=str_remove(street, paste0(" ",suffix,"$"))) %>% 
            select(-name)

#   Look for streets with different suffixes

street_stds %>% group_by(street) %>% filter(n()>1)

#   Read in old data table for merging

old <- readRDS("~/Dropbox/CrimeStats/Street_Standard_Suffix.rds")

#     first time through
street_stds <- old

#   convert to data frame

setDF(old)

newstds <- bind_rows(old, street_stds) %>% unique()

street_stds <- newstds

# Convert to a data.table
  
setDT(street_stds, key="street")

##########    save and/or read in streets standard suffix file

saveRDS(street_stds,"~/Dropbox/CrimeStats/Street_Standard_Suffix.rds")


#     Correct street name suffixes

getnewstreet <- function(checkstreet){
  ans <- street_stds[.(checkstreet), nomatch=NULL]
  setDF(ans)
  if(nrow(ans)==1) {return(paste(ans$street, ans$suffix))
  }
  else {return(checkstreet)}
}

unmatched2 <- 
  unmatched %>% 
  rowwise() %>% 
  mutate(street=getoldstreet(Address)) %>% 
  rowwise() %>% 
  mutate(newstreet=getnewstreet(street)) %>% 
  select(-street)

#   Update Address field with repaired street names

for (i in 1:nrow(unmatched2)) {
  x <- unlist(strsplit(unlist(unmatched2[i,]$Address), ","))
  city <- trimws(x[2])
  state <- trimws(x[3])
  adr <- str_extract(x[1], "^[0-9]+-[0-9]+")
  address <- paste(adr, unmatched2[i,]$newstreet, ",", city, ",", state)
  unmatched2[i,]$Address <- address
}

unmatched2 <- unmatched2 %>% select(Address:newstreet, RawAddress)

keep_unmatched <- unmatched
unmatched <- unmatched2

```

###   did match previously succeed?

```{r check for previous hits}

previous_match <- readRDS( "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

check_match <- function(test_Address, testdata){
    # Did I already succeed at this match somewhere?
    a <- testdata %>% filter(test_Address == Address,
                              status=="success" )
    if (nrow(a)>0){
      return(a)
    } else {return(FALSE)}
}

#   usage:
#   a <- check_match(unmatched[i,], previous_match)
#   if (is_tibble(a)) {unmatched[i,4:10] <- a[1,4:10]
#      print("found previous match")}

```


##  Census Geocoding

Call census geocoder for address, and on success
add in the lat long values as well as other good stuff.

```{r do geocoding}

###############################################################
#############   getlatlong
###############################################################
getlatlong <- function(addr, beat, newaddr){
  x <- unlist(strsplit(unlist(addr), ","))
  city <- trimws(x[2])
  state <- trimws(x[3])
  adr <- unlist(strsplit(str_extract(x[1], "^[0-9]+-[0-9]+"),"-"))[1]
  adr <- str_replace(adr, "00$", newaddr)
  adr <- str_replace(adr, "^0$", newaddr)
  street <- trimws(sub("^[0-9]+-[0-9]+", "", x[1]))
  
  # Pull list of potential zipcodes
  
  ziplist <- BeatToZip[BeatToZip$beat==beat,][2]
  
  # try the various potential zipcodes
  
  keepzip <- NA
  for (zip in unlist(ziplist)) {
    loc <- Census_decoder(paste(adr, street), city, state, zip)
    if (loc[1] != "success"){ # try across the street
      adrplus <- as.character(as.numeric(adr)+1)
      loc <- Census_decoder(paste(adrplus, street), city, state, zip)
    }
    if (loc[1] == "success") {
        # does the street match?
        x <- unlist(strsplit(loc$match_address, ","))
        newstreet <- trimws(sub("^[0-9]+", "", x[1]))
        if (grepl(street, newstreet)) {
          #   sometimes it returns a new zip. Accept the new one.
          keepzip <- x[4]
          
          break # success - break out of loop
        }
    }
  }
  
  # if we couldn't get this test to succeed, then give up.
  
  if (is.na(keepzip)) {
    print("===========")
    print("zip failure")
    print("===========")
    return(data.frame(
      status="fail on zip",
      match_address=x[1],
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  }

  #   return data
  
  return(data.frame(
    status="success",
    match_address=loc$match_address,
    lat=loc[3],
    long=loc[4],
    tract=loc[5],
    block=loc[6]
  ))
  
}

```
##    take care of some special cases

```{r Some special cases}

#  Places that the geocoding generally fails because the addresses 
#  fail to have much meaning, parks, golf courses, malls, etc.

unmatched2 <- unmatched # just in case

###############   special case function
special_case <- function(mydf, mask, address, lat, long){
  if (sum(mask)>0){
    print(paste(sum(mask), "records changed"))
    mydf[mask,]$match_address <- address
    mydf[mask,]$status    <- "success"
    mydf[mask,]$geocode_status    <- "google"
    mydf[mask,]$lat    <- lat
    mydf[mask,]$long   <- long
    mydf[mask,]$GType    <- "RANGE_INTERPOLATED manual"
  }
  return(mydf)
}
#################

mask <- grepl("W MEMORIAL LOOP", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
                "2000 W Memorial Loop Dr, Houston, TX 77007, USA",
                29.774177,
                -95.442344)

mask <- grepl("9 MEMORIAL LOOP", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
                "1000 Memorial Loop Dr, Houston, TX 77007, USA",
                29.775845,
                -95.431376)

mask <- grepl("N PICNIC LN", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
                "6000 N Picnic Ln, Houston, TX 77007, USA",
                29.76546,
                -95.4448)

mask <- grepl("S PICNIC LN", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
                "500 S Picnic Ln, Houston, TX 77007, USA",
                29.763081,
                -95.442344)

mask <- grepl("7\\d{3} MEMORIAL DR", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
                "7500 Memorial Dr, Houston, TX 77007, USA",
                29.766523,
                -95.442661)

mask <- grepl("199 E MEMORIAL LOOP DR", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
                "150 E Memorial Loop Dr, Houston, TX 77007, USA",
                29.764794,
                -95.431154)

mask <- grepl("68\\d{2} MEMORIAL DR", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
                "6850 Memorial Dr, Houston, TX 77007, USA",
                29.765306,
                -95.432661)

mask <- grepl("2499 KATY FWY", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
                "2450 Katy Fwy, Houston, TX 77007, USA",
                29.776653,
                -95.386089)

mask <- grepl("6[12]\\d{2} HERMANN PARK DR", unmatched$Address)
unmatched <- special_case(unmatched, 
                mask,
               "6200 Hermann Park Dr, Houston, TX 77030, USA",
                29.715294,
                -95.389267)

mask <- grepl("5999 HERMANN PARK DR", unmatched$Address) |
        grepl("6099 HERMANN PARK DR", unmatched$Address) 
unmatched <- special_case(unmatched, 
                mask,
               "6000 Hermann Park Dr, Houston, TX 77030, USA",
                29.719581,
                -95.388151)

mask <- grepl("5599 HERMANN PARK DR", unmatched$Address) 
unmatched <- special_case(unmatched, 
                mask,
                "5555 Hermann Park Dr, Houston, TX 77030, USA",
                29.721264,
                -95.389820)

mask <- grepl("GOLF COURSE DR", unmatched$Address) 
unmatched <- special_case(unmatched, 
                mask,
               "6000 Golf Course Dr, Houston, TX 77084, USA",
                29.832923,
                -95.637641)

mask <- grepl("ZOO CIRCLE DR", unmatched$Address) 
unmatched <- special_case(unmatched, 
                 mask, 
                 "1650 Zoo Circle Dr, Houston, TX 77030, USA",
                 29.716162,
                 -95.393259)

mask <- grepl("ALMEDA MALL", unmatched$Address) 
unmatched <- special_case(unmatched, 
                 mask, 
                 "12200 Gulf Fwy, Houston, TX 77034",
                 29.623665,
                 -95.226924 )

mask <- grepl("MEYERLAND PLAZA", unmatched$Address) 
unmatched <- special_case(unmatched, 
                 mask, 
                 "4700 Beechnut St, Houston, TX 77096", 
                 29.688308, 
                 -95.461916)

mask <- grepl("GULFGATE CENTER MALL", unmatched$Address) 
unmatched <- special_case(unmatched, 
                 mask, 
                 "3100 Woodridge Dr, Houston, TX 77087", 
                 29.698329, 
                 -95.297094)

mask <- grepl("NORTHWEST MALL", unmatched$Address) 
unmatched <- special_case(unmatched, 
                 mask, 
                 "9500 Hempstead Rd, Houston, TX 77092", 
                 29.798849, 
                 -95.454829)

mask <- grepl("BAYLOR PLAZA", unmatched$Address) 
unmatched <- special_case(unmatched, 
                 mask, 
                 "1255 Moursund St, Houston, TX 77030", 
                 29.709835, 
                 -95.396725)

mask <- grepl("WEST OAKS MALL", unmatched$Address) 
unmatched <- special_case(unmatched, 
                 mask, 
                 "1000 West Oaks Mall, Houston, TX 77082", 
                 29.733207, 
                 -95.648302)

mask <- grepl("MEMORIAL CITY MALL", unmatched$Address) 
unmatched <- special_case(unmatched, 
                 mask, 
                 "303 Memorial City Way, Houston, TX 77024", 
                 29.780741, 
                 -95.535961)





```

##  match against census

```{r Now work through census data}

#   Percent of unique addresses found, and percent of total found

unmatched %>% 
  group_by(status) %>% 
  summarise(n=n())

# re-edit addresses

#unmatched <- readRDS( "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

source("Edit_Addresses.R") # load in address edits

dict <- Makedict(dictionary)
#   test them first
testregex(unmatched, "Address", dict)
#   Apply
unmatched <- applyregex(unmatched, "Address", dict)

#    special cases - digits replace last 2 on address
special <- tribble(
  ~match, ~addr,
  "GREENWAY PLAZA DR", "03",
  "SEAGLER ",          "03",
  "EAGLE VISTA ",      "03",
  "HERMANN MUSEUM CIR DR", "03",
  "IRVINGTON BLVD",    "05",
  "LIVORNO WAY",       "05",
  "CUMMINS ST",        "15",
  "S HEIGHTS BLVD",    "15",
  "MT VERNON ST",      "15",
  "EMANUEL ST",        "15",
  "MOURSUND ST",       "15",
  "S CALUMET ST",      "16",
  " EAST ",            "41",
  " HARWIN ",          "50",
  "CETTIPARK ST",      "10"
)

# Skip these, census won't get them, this will speed things up

skips <- c("S HEIGHTS", "FWY", "HOMELESS", "PO BOX", "POBOX","WASHINGTON", "HAYS", "POST OAK", "SAM HOUSTON", "PKWY", "WOODFAIR")

onlys <- c("SYNOTT", "WILCREST", "BELLFORT")

##########################################
##    spin through data geocoding
##########################################

begin <- 1
successes <- 0
trys <- 0
starttime <- now()

for (i in begin:nrow(unmatched)) {
  if (i==begin){starttime <- now()}
#for (i in begin:(begin+98)) {
#for (i in 572:572) {
  if (unmatched[i,]$status!="success"){ # only the redo's
    # skip hopeless cases
    if (any(str_detect(unmatched[i,]$Address, skips))){next()}
    # only do selected cases
    #if (!any(str_detect(unmatched[i,]$Address, onlys))){next()}
    trys <- trys + 1
    print(paste("--->",i,unmatched[i,1], 
                now()+((now()-starttime)/trys)*(nrow(unmatched)-i)
          ))
    # Did I already succeed at this match somewhere?
    a <- check_match(unmatched[i,]$Address, previous_match)
    if (is_tibble(a)) {
      unmatched[i,4:10] <- a[1,4:10]
      print("found previous match in archive")
      next
    }
    a <- check_match(unmatched[i,]$Address, unmatched)
    if (is_tibble(a)) {
      unmatched[i,4:10] <- a[1,4:10]
      print("found previous match in current")
      next
    }
    
    newaddr <- "30"
     
    if (grepl("FWY", unmatched[i,]$Address)){newaddr <- "15"}
    
    if(any(str_detect(unmatched[i,]$Address, special$match))){
      newaddr <- special[str_detect(unmatched[i,]$Address, special$match),]$addr
    }
    
    latlong <- getlatlong(unmatched[i,]$Address, unmatched[i,]$Beat, newaddr)
    if (latlong$status=="success") {
      successes <- successes + 1
      #print(paste("=======final=======",latlong[1,]))
      unmatched[i,]$match_address  <- latlong$match_address
      unmatched[i,]$lat            <- latlong$lat
      unmatched[i,]$long           <- latlong$long
      unmatched[i,]$tract          <- latlong$tract
      unmatched[i,]$block          <- latlong$block
      unmatched[i,]$geocode_status <- "census"
      unmatched[i,]$status         <- latlong$status
    } else {
      unmatched[i,]$geocode_status <- "census fail"
      unmatched[i,]$status         <- latlong$status
    }
  }
  if ((i+1)%%100 == 0){
    saveRDS(unmatched, "~/Dropbox/CrimeStats/CensusGeoTable_progress_temp.rds")
    print(paste("successes =", successes))
    
  }
}
print(paste("successes =", successes))

saveRDS(unmatched, "~/Dropbox/CrimeStats/CensusGeoTable_progress_temp.rds")

keep_unmatched <- unmatched
unmatched <- keep_unmatched

  #   Are we within the city?
for (i in 1:nrow(unmatched)){  
  if (!is.na(unmatched[i,]$lat) &
      (!between(unmatched[i,]$lat, HoustonBdy[2], HoustonBdy[4]) |
       !between(unmatched[i,]$long, HoustonBdy[1], HoustonBdy[3]))){
    print(paste("---", i))
    unmatched[i,]$geocode_status <- "census fail"
    unmatched[i,]$match_address <- NA
    unmatched[i,]$lat <- NA
    unmatched[i,]$long <- NA
    unmatched[i,]$tract <- NA
    unmatched[i,]$block <- NA
    unmatched[i,]$status <- "pending"
  }
}
```

```{r look at misses}

#   Look at the failures - first strip number and consolidate

unmatched %>% 
  filter(grepl("fail", geocode_status)) %>% 
  mutate(street=sub("^[0-9]+-[0-9]+", "", Address))  %>% 
  mutate(street=trimws(str_extract(street, "[A-Z ]+")))  %>% 
  group_by(street) %>% 
  summarise(nn=sum(n)) %>% 
  arrange(-nn)
```

###  Now we will turn to Google for the rest

```{r GetLatLongGoogle}

#   Function for pulling fields out of nested lists returned by geocode
getfields <- function(x){
              if(! is.na(x) && length(x$results)>0)  {tibble(
              lat=as.numeric(x$results[[1]]$geometry$location$lat),
              long=as.numeric(x$results[[1]]$geometry$location$lng),
              match_address=x$results[[1]]$formatted_address,
              LocType=x$results[[1]]$geometry$location_type,
              Type=unlist(x$results[[1]]$types[1])
              )
              } else if ("status" %in% names(x) &&
                         x$status=="ZERO_RESULTS"){
                tibble(Type=x$status,lat=NA,long=NA,
                           match_address=NA,LocType=NA )
              } else{
                tibble(Type=NA,lat=NA,long=NA,
                           match_address=NA,LocType=NA )
              }
}

#     Process google results and check for accuracy

GetLatLongGoogle <- function(address, newaddr){
  # prepare address
  x <- unlist(strsplit(unlist(address), ","))
  city <- trimws(x[2])
  state <- trimws(x[3])
  adr <- unlist(strsplit(str_extract(x[1], "^[0-9]+-[0-9]+"),"-"))[1]
  adr <- str_replace(adr, "00$", newaddr)
  adr <- str_replace(adr, "^0$", newaddr)
  street <- trimws(sub("^[0-9]+-[0-9]+", "", x[1]))
  address <- paste(adr, street, ",", city, ",", state)
  
  #   get results from given address
  
  #GoogleResults <- geocode(address, output="all")
  GoogleResults <- geocode(address, output="all", inject=BoundBox)
  LatLong1 <- getfields(GoogleResults)
  
  #   Did we error?
  
  if (is.na(LatLong1$Type) |
      LatLong1$Type == "ZERO_RESULTS"){
          LatLong1$status <- "no result"
          return(LatLong1)
      }
  
  #   Are we within the city?
  
  if (!between(LatLong1$lat, HoustonBdy[2], HoustonBdy[4]) |
      !between(LatLong1$long, HoustonBdy[1], HoustonBdy[3])){
          LatLong1$status <- "outside boundary"
          return(LatLong1)
      }
  
  #   Is it a bogus location at center of long street?
  
  if (LatLong1$LocType == "GEOMETRIC_CENTER") { # bad location
          LatLong1$status <- "Road only, street number ignored"
          return(LatLong1)
  }
  
  # REALLY bogus location - don't want this
    
  if (LatLong1$LocType == "APPROXIMATE" ) { # bad location
          LatLong1$status <- "City only, street ignored"
          return(LatLong1)
  }
  
  #   Is the match name "close enough"?
  x <- unlist(strsplit(unlist(LatLong1$match_address), ","))
  #utstreet <- trimws(sub("^[0-9]+", "", x[1]))
  utstreet <- trimws(x[1])
  if (tolower(paste(adr,street)) != tolower(utstreet)){
          LatLong1$status <- "Names mismatch"
          return(LatLong1)
  }
  
  #   Now tweak the street number and get a new set
  #   unless LocType == "ROOFTOP"
  
  if (LatLong1$LocType != "ROOFTOP") { # interpolated location
      addrnumber <- str_extract(address, "^[0-9]+ ")
      addrnumber2 <- as.character(as.numeric(addrnumber)+15)
      address <- str_replace(address, addrnumber, addrnumber2)
      GoogleResults <- geocode(address, output="all")
      LatLong2 <- getfields(GoogleResults)
        
    #   Are the answers the same? If so, we have a problem
      distance <- dist(rbind(c(LatLong1$lat, LatLong1$long),
                        c(LatLong2$lat, LatLong2$long))) *
                        69*5280
      if (distance < 10){# could be almost anywhere, reject
          LatLong1$status <- paste("Distance =",as.character(distance))
          return(LatLong1)
      }
  }
  #   All the tests passed, successful return
        LatLong1$status <- "success"
        return(LatLong1)
  
}

```

```{r Fix tollway}

keep_unmatched <- unmatched

#   Use Beat to guess if it is W Sam Houston Pkwy S or N.
#   Changeover point is Buffalo Bayou
#   Changeover from W Sam to S Sam is Bellfort.
#   Changeover from S Sam E to S Sam W is 288, South Fwy
#   Google in error, thinks S Sam W is W Sam S from addresses>11,000

samWS <- c("19G10", "19G20", "19G30", "19G40", "19G50", "20G10", "20G20", "20G30", "20G40")

samWN <- c("20G50", "20G60", "5F30", "4F10", "4F20", "4F30")

samSE <- c("14D50", "13D40", "12D20")

samSW <- c("17E30", "16E30", "16E40")

samES <- c("12D30", "12D40", "11H40", "9C40")

samEN <- c("24C60")

samNE <- c("22B40", "22B20", "22B30")

#-----  W Sam
mask <- grepl("W SAM HOUSTON PKWY ,", unmatched$Address)
for (beat in samWS){
  unmatched$Address[mask&(unmatched$Beat==beat)] <-
    str_replace(unmatched$Address[mask&(unmatched$Beat==beat)], "PKWY", "PKWY S")
}
for (beat in samWN){
  unmatched$Address[mask&(unmatched$Beat==beat)] <-
    str_replace(unmatched$Address[mask&(unmatched$Beat==beat)], "PKWY", "PKWY N")
}

#-----  S Sam
mask <- grepl("S SAM HOUSTON PKWY ,", unmatched$Address)
for (beat in samSW){
  unmatched$Address[mask&(unmatched$Beat==beat)] <-
    str_replace(unmatched$Address[mask&(unmatched$Beat==beat)], "PKWY", "PKWY W")
}
for (beat in samSE){
  unmatched$Address[mask&(unmatched$Beat==beat)] <-
    str_replace(unmatched$Address[mask&(unmatched$Beat==beat)], "PKWY", "PKWY E")
}


mask <- grepl("W SAM HOUSTON PKWY S", unmatched$Address)
for ( i in c("11500", "11600", "11700", "11800", "11900")){
unmatched$Address[mask&(grepl(i, unmatched$Address))] <- 
    str_replace(unmatched$Address[mask&(grepl(i, unmatched$Address))], 
    "W SAM HOUSTON PKWY S", "S SAM HOUSTON PKWY W")
}

mask <- grepl("W SAM HOUSTON PKWY N", unmatched$Address) &
        grepl("mismatch", unmatched$status)
unmatched$Address[mask] <- 
    str_replace(unmatched$Address[mask], " W ", " WEST ")


```


##    And here we run google

```{r run google}

# re-edit addresses

#unmatched <- readRDS( "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

source("Edit_Addresses.R") # load in address edits

dict <- Makedict(dictionary)
#   test them first
testregex(unmatched, "Address", dict)
#   Apply
unmatched <- applyregex(unmatched, "Address", dict)

#   Edits just for Google - census doesn't like them

source("Edit_Google_Addresses.R") # load in address edits

dict <- Makedict(dictionary)
#   test them first
testregex(unmatched, "Address", dict)
#   Apply
unmatched <- applyregex(unmatched, "Address", dict)

#    special cases - digits replace last 2 on address
special <- tribble(
  ~match, ~addr,
  "GREENWAY PLAZA DR", "03",
  "SEAGLER",           "03",
  "IRVINGTON BLVD",    "05",
  "N CALUMET",         "05",
  "CUMMINS ST",        "15",
  "WEST DR",           "60",
  "SAWYER HEIGHTS",    "24",
  "N SAN JACINTO",     "15",
  "S HEIGHTS BLVD",    "15",
  "VERNON ST",         "15",
  "11TH PLACE",        "03",
  "DELWIN ST",         "15",
  "MEMORIAL CT",       "15",
  "VISTA WOODS DR",    "15",
  "W HEIGHTS HOLLOW LN","15",
  "EAST",              "41",
  "CETTIPARK ST",      "10"
)

# Skip these, won't get them, this will speed things up

skips <- c("HOMELESS", "PO BOX", "POBOX", "ENTRANCE", "P O BOX")

onlys <- c("KATY")

##########################################
##    next spin through data geocoding
##########################################

###unmatched <- unmatched %>% mutate(GType=NA) # add new information column


geocodeQueryCheck()
begin <- 1
for (i in begin:nrow(unmatched)) {
#for (i in begin:(begin+98)) {
#for (i in 151:151) {
  if (unmatched[i,]$status!="success"){ # only the redo's
    # skip cases with no street name
    if (grepl("99 +,", unmatched[i,]$Address)){print("--no street--")
      next()}
    # skip hopeless cases
    if (any(str_detect(unmatched[i,]$Address, skips))){next()}
    # only do selected cases
    if (!any(str_detect(unmatched[i,]$Address, onlys))){next()}
    # skip distance <10 cases
    #if (unmatched[i,]$status=="Distance = 0"){next()}
    # skip GEOMETRIC_CENTER cases
    #if(!is.na(unmatched[i,]$GType) &
    #    unmatched[i,]$GType == "GEOMETRIC_CENTER route") {next()}
    print(paste("--->",i,unmatched[i,1], 
                format(Sys.time(), "%a %b %d %X %Y")))
    # Did I already succeed at this match somewhere?
    a <- check_match(unmatched[i,]$Address, previous_match)
    if (is_tibble(a)) {
      unmatched[i,4:10] <- a[1,4:10]
      print("found previous match in archive")
      next
    }
    a <- check_match(unmatched[i,]$Address, unmatched)
    if (is_tibble(a)) {
      unmatched[i,4:10] <- a[1,4:10]
      print("found previous match in current")
      next
    }
    a <- check_match(unmatched[i,]$Address, generated)
    if (is_tibble(a)) {
      unmatched[i,4:10] <- a[1,4:10]
      print("found previous match in generated")
      next
    }

    newaddr <- str_pad(as.character(sample(0:50, 1)),2,pad="0")
    if (grepl("FWY", unmatched[i,]$Address)){newaddr <- "11"}
    if(any(str_detect(unmatched[i,]$Address, special$match))){
      newaddr <- special[str_detect(unmatched[i,]$Address, special$match),]$addr
    }
    
    #   Call google
    
    latlong <- GetLatLongGoogle( unmatched[i,]$Address, newaddr)
    if (latlong$status=="success") {
      #print(paste("=======final=======",latlong[1,]))
      print(paste("=======success======="))
      unmatched[i,]$match_address  <- latlong$match_address
      unmatched[i,]$lat            <- latlong$lat
      unmatched[i,]$long           <- latlong$long
      unmatched[i,]$geocode_status <- "google"
      unmatched[i,]$status         <- latlong$status
      unmatched[i,]$GType          <- paste(latlong$LocType, latlong$Type)
    } else if (latlong$status=="Names mismatch"){
      print(paste("=======fail=======",latlong[1,]))
      unmatched[i,]$geocode_status <- "google fail"
      unmatched[i,]$status         <- latlong$status
      unmatched[i,]$GType          <- paste(latlong$LocType, latlong$Type)
      unmatched[i,]$match_address  <- latlong$match_address
    } else{
      print(paste("=======fail======="))
      unmatched[i,]$geocode_status <- "google fail"
      unmatched[i,]$status         <- latlong$status
      unmatched[i,]$GType          <- paste(latlong$LocType, latlong$Type)
      unmatched[i,]$match_address  <- latlong$match_address
    }
  }
  if ((i+1)%%100 == 0){
    saveRDS(unmatched, "~/Dropbox/CrimeStats/CensusGeoTable_progress_temp.rds")
    
  }
}

old <- readRDS("~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

new <- bind_rows(old, unmatched) %>% unique()

saveRDS(new, "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

#   Percent of unique addresses found, and percent of total found

unmatched %>% 
  group_by(geocode_status) %>% 
  summarise(n=n())


```

```{r test google geocode}

addrs <- c("1300-1399 TULANE ST, HOUSTON, TX",
           "1700-1799 TULANE ST, HOUSTON, TX") 

for (i in 1:2) {
    print(paste("--->",i,addrs[i]))
    newaddr <- "30"
    if (grepl("FWY", addrs[i])){newaddr <- "15"}
    
    #   Call google
    
    latlong <- GetLatLongGoogle( addrs[i], newaddr)
    if (latlong$status=="success") {
      print(paste("=======final=======",latlong[1,]))
    } else {
      print(paste("=======fail=======",latlong[1,]))
    }
}


```

```{r interpolate katy fwy}

#   create dataframe of good lat long to interpolate with 
dfstart <- 
bind_rows(previous_match, unmatched) %>% 
  filter(status=="success") %>% 
  filter(grepl("katy fwy", tolower(match_address))) %>% 
  select(match_address, lat, long) %>%
  mutate(addr=as.numeric(str_extract(match_address, "^[0-9]+"))) %>% 
  unique() %>% 
  arrange(addr) 
  
#   Create points to interpolate to
dftargets <- seq(2550,21750,by=100)

# interpolate
newlat <- approx(dfstart$addr, dfstart$lat, dftargets)
newlon <- approx(dfstart$addr, dfstart$long, dftargets)

#   Create a new dataframe with all "addresses" in it
generated <- tibble(addr=newlat$x, lat=newlat$y, long=newlon$y) %>% 
  mutate(Address=paste0(as.character(addr-50),"-",
                        as.character(addr+49),
                        " KATY FWY , Houston , TX")) %>% 
  mutate(Beat=NA, n=0, geocode_status="generated", 
         match_address=paste(as.character(addr),"Katy Fwy, Houston, TX"),
         tract=NA, block=NA, status="success") %>% 
  select(Address:match_address,lat, long, tract, block, status)

saveRDS(generated, "~/Dropbox/CrimeStats/Generated_Coordinates.rds")

```



```{r fix stuff}

mask <- grepl("MT VERNON", unmatched$RawAddress)

unmatched[mask,]$newstreet <- "MT VERNON ST"
unmatched[mask,]$status    <- "Names mismatch"
unmatched[mask,]$Address  <- str_replace(unmatched[mask,]$Address, "9 V", "9 MT V")

#-------------------------------------

mask <- grepl(" SH 6 ", unmatched$RawAddress)

unmatched[mask,]$lat <- NA
unmatched[mask,]$long <- NA
unmatched[mask,]$status    <- "Names mismatch"
unmatched[mask,]$geocode_status    <- "google fail"
unmatched[mask,]$Address  <- str_replace(unmatched[mask,]$Address, "SAM HOUSTON PKWY W", "SH 6")

#------------------------------------------
#Bad address match()
unmatched %>% 
  filter(status=="success") %>% 
  mutate(inaddress=as.numeric(str_extract(Address, "^[0-9]+"))) %>% 
  mutate(utaddress=as.numeric(str_extract(match_address, "^[0-9]+"))) %>% 
  filter(inaddress-utaddress>100) %>% 
  head()

unmatched2 <- unmatched

for (i in 1:nrow(unmatched)) {
  if(unmatched[i,]$status=="success" &
    ((as.numeric(str_extract(unmatched[i,]$Address, "^[0-9]+")) - 
     as.numeric(str_extract(unmatched[i,]$match_address, "^[0-9]+")))>100)) {
        print(paste("-----", i))
        unmatched[i,]$lat <- NA
        unmatched[i,]$long <- NA
        unmatched[i,]$status    <- "Names mismatch"
        unmatched[i,]$geocode_status    <- "google fail"
    
     }
}


```

