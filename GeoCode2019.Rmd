---
title: "Geocode2019"
author: "Alan Jackson"
date: "January 7, 2019"
output: html_document
---

```{r setup, include=FALSE}

library(tidyverse)
library(stringr)
library(dplyr)
library(ggmap)

options(stringsAsFactors = FALSE)

apikey <- readRDS("~/Dropbox/CrimeStats/apikey.rds")
register_google(key = apikey)

HoustonBdy <- c(-95.789963, 29.518566, -95.005814, 30.117875)

reclean <- c("District1aReCleanData.rds", 
             "District2aReCleanData.rds")
recleanpath <- "~/Dropbox/CrimeStats/"

dflist <- vector(mode = "list", length = 2)
for (i in 1:2) {
    dflist[[i]] <- as.tibble(readRDS(paste0(recleanpath, reclean[i])))
}

BeatToZip <- as.tibble(readRDS("~/Rprojects/CrimeStats/BeatToZip.rds"))

source("Edit_Addresses.R") # load in address edits

knitr::opts_chunk$set(echo = TRUE)
```

```{r define functions}

#     Create dictionary data frame of pattern/replacement
Makedict <- function(dictionary) {
  dict <- cbind.data.frame(split(dictionary, rep(1:2, times=length(dictionary)/2)), stringsAsFactors=F)
  names(dict) <- c("From", "To")
  return(dict)
}

#   test the searches first to see what they will find
testregex <- function(dframe, col, pat) { # input data frame and regex
  for(i in 1:length(pat[,1])) {
    print(paste("Pattern: ",pat[i,1]))
    hits <- unique(dframe[[col]][grepl(pat[i,1],dframe[[col]])])
    if (length(hits)>0){
      print(paste("   Result: ", hits))
    }
    else {
      print("No hits")
    }
  }
}

#   apply to input array
applyregex <- function(dframe, col, pat) {
  for(i in 1:length(pat[,1])) {
  dframe[[col]] <- str_replace_all(dframe[[col]],pat[i,1],pat[i,2])
  }
  return(dframe)
}

#   Following is sample of how to apply

#  dictionary <- c(
#                  " *P*O* BOX\\s\\d* *","",
#                  " *BOX\\s\\d* *","",
#                  "P *O BX",""
#  )
#  dict <- Makedict(dictionary)
#  #   test them first
#  testregex(df2, "Street", dict)
#  #   Apply
#  df2 <- applyregex(df2, "Street", dict)

```


Call sequence is

* address (required): street number and street name (1234 N Main ST)
* city (optional): City name. If both city and zip are given, they may conflict.
* state (optional): State 2-letter postal abbreviation
* zip (optional): 5 digit US Postal Zipcode

Either city and state, or zip is required

Will return the last match if there are multiple matches. That way downtown Houston will not show up as "Clutch City".

Returns will be:

* status code: 
  + "success"=success 
  + "multiples"=success but multiple answers
  + "partial match"=success but not a 100% match with input address 
  + "fail"=fail
* matching address
* lat
* long
* tract
* block

```{r census geocoder}

###############################################################
#############   GetResult
###############################################################
GetResult <- function(urlreq) {
  #  required libraries 
  
  require(httr)
  
  #   set up to retry twice on server type error (which usually works)
  attempt <- 1
  result <- data.frame(status_code=0)
  while(result$status_code!=200 && attempt<=3 ) {
    if (attempt>1){print(paste("attempted", attempt))}
    attempt <- attempt + 1
    try(
      #     Go get result
      result <- httr::GET(urlreq)
    )
  }
  return(result)
}
###############################################################
#############   Census_decoder
###############################################################
Census_decoder <- function(address, city=NA, state=NA, zip=NA){
  
  urlreq <- paste0("https://geocoding.geo.census.gov/geocoder/geographies/address?street=",gsub(" ", "+",address))
  if (!is.na(city)){urlreq <- paste0(urlreq,"&city=", city)}
  if (!is.na(state)){urlreq <- paste0(urlreq,"&state=", state)}
  if (!is.na(zip)){urlreq <- paste0(urlreq,"&zip=", zip)}
  urlreq <- paste0(urlreq,"&benchmark=Public_AR_Current&vintage=Current_Current&format=json")
  
  print(urlreq)
  result <- GetResult(urlreq)
  #     did we succeed?
  if (result$status_code != 200) { # failure
    return(data.frame(
      status=paste("fail_code: ",result$status_code),
      match_address=NA,
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  } else {
  result <- httr::content(result)
  Num_matches <- length(result[["result"]][["addressMatches"]])
  
  if (Num_matches <= 0) { # failed to find address
    return(data.frame(
      status="fail_length",
      match_address=NA,
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  }
    
    # pick matching result if multiples offered
  for (i in 1:Num_matches) {
    temp <- result[["result"]][["addressMatches"]][[i]]
    if (grepl(address, 
        str_split(temp[["matchedAddress"]], ",")[1])) { break }
  }
    tract <- temp[["geographies"]][[
                   "2010 Census Blocks"]][[1]][["TRACT"]]
    if (is.null(tract)){
      return(data.frame(
        status="fail_tract",
        match_address=NA,
        lat=NA,
        long=NA,
        tract=NA,
        block=NA
      ))
    }
    status <- "success"
    match_address=temp[["matchedAddress"]] 
    lat=temp[["coordinates"]][["y"]]
    long=temp[["coordinates"]][["x"]]
    tract=temp[["geographies"]] [[
                "2010 Census Blocks"]][[1]][["TRACT"]]
    block=temp[["geographies"]] [[
                "2010 Census Blocks"]][[1]][["BLOCK"]]
    
    return(data.frame(
      status=status,
      match_address=match_address,
      lat=lat,
      long=long,
      tract= tract,
      block=block
    ))
  } # end if/else
}
```

## Prep data

1. reduce to unique addresses
2. apply edits


```{r prep data}

# Read in clean data files

df <- dplyr::bind_rows(dflist)


  # create address in df: 
  # Block_Range + Suffix + Street + Type + ", Houston, TX"

df$Address <- paste(df$Block_Range, df$Suffix, df$Street, df$Type, ", Houston, TX")
df$Address <- str_replace_all(df$Address, "- ", "")
df$Address <- str_replace_all(df$Address, "  ", " ")

# flag records not matchable

df <- df %>% 
  mutate(geocode_status=case_when(
    grepl("^UNK", Block_Range) ~ "not possible",
    grepl(" NA ", Address)     ~ "not possible",
    grepl("^UNK ", Address)    ~ "not possible",
    TRUE                       ~ "pending"
      )
    )

# Apply edits to Address field

# Make a list of unique addresses and beats for pending and count

unmatched <- df %>%
  filter(geocode_status=="pending") %>%
  add_count(Address, Beat) %>% 
  select(Address, Beat, n, geocode_status) %>%  
  distinct() %>% 
  arrange(-n) # focus on most important first

# edit addresses

dict <- Makedict(dictionary)
#   test them first
testregex(unmatched, "Address", dict)
#   Apply
unmatched <- applyregex(unmatched, "Address", dict)

# Puff up unmatched with empty columns

unmatched <- 
  unmatched %>% 
  mutate(match_address=NA,
         lat=NA,
         long=NA,
         tract=NA,
         block=NA,
         status=NA )

```

##   Street name cleanup functions

```{r cleanup functions}

# address of form [0-9]+ [NSEW] name suffix , city, state, zip, USA
getstreet <- function(address) {
  x <- unlist(strsplit(unlist(address), ","))
  street <- trimws(sub("^[0-9]+", "", x[1]))
  return(street)
}

# address of form [0-9]+-[0-9]+ [NSEW] name suffix , city, state, zip, USA
getoldstreet <- function(address) {
  x <- unlist(strsplit(unlist(address), ","))
  street <- trimws(sub("^[0-9]+-[0-9]+", "", x[1]))
  return(street)
}

# pull final string off street and test if is a valid suffix
getsuffix <- function(street) {
  suffixes <- c("FWY", "CIR", "ST", "RD", "DR", "AVE", "LN", "BLVD",
               "PL", "CT", "PKWY", "TER", "LNDG", "WAY", "TRL",
               "FREEWAY", "CIRCLE", "STREET", "ROAD", "DRIVE",
               "AVENUE", "LANE", "BOULEVARD", "PLACE", "COURT", "PARKWAY",
               "TERRACE", "LANDING", "WAY", "TRAIL")
  suffix <- tail(unlist(strsplit(street,split=" ")),1)
  if (any(suffix==suffixes)) {
    return(suffix)
  } else {return(" ")}
}

```

##  create a file for checking suffixes

```{r suffixes}

# pull out good matched addresses

addresses <- unmatched %>% filter(geocode_status=="census" |
                                  geocode_status=="google") %>% 
                   select(match_address) %>% 
                   mutate(match_address=toupper(match_address)) %>% 
                   unique() 
#   strip out the street names
streets <- addresses$match_address %>% map(getstreet) %>% unique()
streets <- enframe(unlist(streets),value="street")

#   separate street name from suffix
street_stds <- streets %>% #  standard names and suffixes
            rowwise() %>% 
            mutate(suffix=getsuffix(street)) %>% 
            mutate(street=str_remove(street, paste0(" ",suffix,"$"))) %>% 
            select(-name)

# Convert to a data.table
  
setDT(street_stds, key="street")

#     Correct street name suffixes

getnewstreet <- function(checkstreet){
  ans <- street_stds[.(checkstreet), nomatch=NULL]
  setDF(ans)
  if(nrow(ans)==1) {return(paste(ans$street, ans$suffix))
  }
  else {return(checkstreet)}
}

unmatched <- 
unmatched %>% 
  rowwise() %>% 
  mutate(street=getoldstreet(Address)) %>% 
  rowwise() %>% 
  mutate(newstreet=getnewstreet(street)) %>% 
  select(-street)


```
##  Census Geocoding

Call census geocoder for first and last address, and on success
average the two answers and add in the lat long values as well as other good stuff.

```{r do geocoding}

###############################################################
#############   getlatlong
###############################################################
getlatlong <- function(addr, beat, newaddr){
  x <- unlist(strsplit(unlist(addr), ","))
  city <- trimws(x[2])
  state <- trimws(x[3])
  adr <- unlist(strsplit(str_extract(x[1], "^[0-9]+-[0-9]+"),"-"))[1]
  adr <- str_replace(adr, "00$", newaddr)
  adr <- str_replace(adr, "^0$", newaddr)
  street <- trimws(sub("^[0-9]+-[0-9]+", "", x[1]))
  
  # Pull list of potential zipcodes
  
  ziplist <- BeatToZip[BeatToZip$beat==beat,][2]
  
  # try the various potential zipcodes
  
  keepzip <- NA
  for (zip in unlist(ziplist)) {
    loc <- Census_decoder(paste(adr, street), city, state, zip)
    if (loc[1] != "success"){ # try across the street
      adrplus <- as.character(as.numeric(adr)+1)
      loc <- Census_decoder(paste(adrplus, street), city, state, zip)
    }
    if (loc[1] == "success") {
        # does the street match?
        x <- unlist(strsplit(loc$match_address, ","))
        newstreet <- trimws(sub("^[0-9]+", "", x[1]))
        if (grepl(street, newstreet)) {
          #   sometimes it returns a new zip. Accept the new one.
          keepzip <- x[4]
          
          break # success - break out of loop
        }
    }
  }
  
  # if we couldn't get this test to succeed, then give up.
  
  if (is.na(keepzip)) {
    print("===========")
    print("zip failure")
    print("===========")
    return(data.frame(
      status="fail on zip",
      match_address=x[1],
      lat=NA,
      long=NA,
      tract=NA,
      block=NA
    ))
  }

  #   return data
  
  return(data.frame(
    status="success",
    match_address=loc$match_address,
    lat=loc[3],
    long=loc[4],
    tract=loc[5],
    block=loc[6]
  ))
  
}

```

```{r Do geocoding}

#####################################
##    spin through data geocoding
#####################################

begin <- 1
#for (i in begin:nrow(unmatched)) {
for (i in begin:(begin+999)) {
#for (i in 572:572) {
  print(paste("--->",i,unmatched[i,1]))
  newaddr <- "30"
  if (grepl("FWY", unmatched[i,]$Address)){newaddr <- "15"}
  latlong <- getlatlong(unmatched[i,]$Address, unmatched[i,]$Beat, newaddr)
  if (latlong$status=="success") {
    #print(paste("=======final=======",latlong[1,]))
    unmatched[i,]$match_address  <- latlong$match_address
    unmatched[i,]$lat            <- latlong$lat
    unmatched[i,]$long           <- latlong$long
    unmatched[i,]$tract          <- latlong$tract
    unmatched[i,]$block          <- latlong$block
    unmatched[i,]$geocode_status <- "census"
    unmatched[i,]$status         <- latlong$status
  } else {
    unmatched[i,]$geocode_status <- "census fail"
    unmatched[i,]$status         <- latlong$status
  }
}

saveRDS(unmatched, "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

```


---- census errors (they want the wrong name)

W DALLAS ST   -> W DALLAS AVE
MID LN        -> MID LANE DR


```{r do some stats}

#   Percent of unique addresses found, and percent of total found

unmatched %>% 
  group_by(status) %>% 
  summarise(n=n())

# re-edit addresses

unmatched <- readRDS( "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

source("Edit_Addresses.R") # load in address edits

dict <- Makedict(dictionary)
#   test them first
testregex(unmatched, "Address", dict)
#   Apply
unmatched <- applyregex(unmatched, "Address", dict)

#    special cases - digits replace last 2 on address
special <- tribble(
  ~match, ~addr,
  "GREENWAY PLAZA DR", "03",
  "IRVINGTON BLVD",    "05",
  "CUMMINS ST",        "15",
  "S HEIGHTS BLVD",    "15",
  "VERNON ST",         "15",
  "EAST",              "41",
  "CETTIPARK ST",      "10"
)

# Skip these, census won't get them, this will speed things up

skips <- c("MEMORIAL", "SAWYER", "S HEIGHTS", "FWY", "PICNIC", "HOMELESS", "PO BOX", "POBOX","WASHINGTON", "HAYS", "POST OAK")

onlys <- c("S HEIGHTS", "EAST ST", "MID LANE", "WEST ST",
           "BRAEBURNE", "HARVARD", "OXFORD", "PARK TRAIL",
           "COTTAGE")

##########################################
##    second spin through data geocoding
##########################################


begin <- 1000
for (i in begin:nrow(unmatched)) {
#for (i in begin:(begin+999)) {
#for (i in 572:572) {
  if (unmatched[i,]$status!="success"){ # only the redo's
    # skip hopeless cases
    #if (any(str_detect(unmatched[i,]$Address, skips))){next()}
    # only do selected cases
    if (!any(str_detect(unmatched[i,]$Address, onlys))){next()}
    print(paste("--->",i,unmatched[i,1]))
    # Did I already succeed at this match somewhere?
    a <- unmatched %>% filter(Address == unmatched[i,]$Address,
                              status=="success" )
    if (nrow(a)>0){
      unmatched[i,4:10] <- a[1,4:10]
      print("found previous match")
      next
    }
    newaddr <- "30"
    #special[grep(unmatched[i,1], special$match), ]
    if (grepl("FWY", unmatched[i,]$Address)){newaddr <- "15"}
    if(any(str_detect(unmatched[i,]$Address, special$match))){
      newaddr <- special[str_detect(unmatched[i,]$Address, special$match),]$addr
    }
    
    latlong <- getlatlong(unmatched[i,]$Address, unmatched[i,]$Beat, newaddr)
    if (latlong$status=="success") {
      #print(paste("=======final=======",latlong[1,]))
      unmatched[i,]$match_address  <- latlong$match_address
      unmatched[i,]$lat            <- latlong$lat
      unmatched[i,]$long           <- latlong$long
      unmatched[i,]$tract          <- latlong$tract
      unmatched[i,]$block          <- latlong$block
      unmatched[i,]$geocode_status <- "census"
      unmatched[i,]$status         <- latlong$status
    } else {
      unmatched[i,]$geocode_status <- "census fail"
      unmatched[i,]$status         <- latlong$status
    }
  }
}

saveRDS(unmatched, "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

```

```{r look at misses}

#   Look at the failures - first strip number and consolidate

unmatched %>% 
  filter(geocode_status=="census fail") %>% 
  mutate(street=sub("^[0-9]+-[0-9]+", "", Address))  %>% 
  mutate(street=trimws(str_extract(street, "[A-Z ]+")))  %>% 
  group_by(street) %>% 
  summarise(nn=sum(n)) %>% 
  arrange(-nn)
```

###  Now we will turn to Google for the rest

```{r GetLatLongGoogle}

#   Function for pulling fields out of nested lists returned by geocode
getfields <- function(x){
              if(! is.na(x) && length(x$results)>0)  {tibble(
              lat=as.numeric(x$results[[1]]$geometry$location$lat),
              long=as.numeric(x$results[[1]]$geometry$location$lng),
              match_address=x$results[[1]]$formatted_address,
              LocType=x$results[[1]]$geometry$location_type,
              Type=unlist(x$results[[1]]$types[1])
              )
              } else if ("status" %in% names(x) &&
                         x$status=="ZERO_RESULTS"){
                tibble(Type=x$status,lat=NA,long=NA,
                           match_address=NA,LocType=NA )
              } else{
                tibble(Type=NA,lat=NA,long=NA,
                           match_address=NA,LocType=NA )
              }
}

#     Process google results and check for accuracy

GetLatLongGoogle <- function(address, newaddr){
  # prepare address
  x <- unlist(strsplit(unlist(address), ","))
  city <- trimws(x[2])
  state <- trimws(x[3])
  adr <- unlist(strsplit(str_extract(x[1], "^[0-9]+-[0-9]+"),"-"))[1]
  adr <- str_replace(adr, "00$", newaddr)
  adr <- str_replace(adr, "^0$", newaddr)
  street <- trimws(sub("^[0-9]+-[0-9]+", "", x[1]))
  address <- paste(adr, street, ",", city, ",", state)
  
  #   get results from given address
  
  GoogleResults <- geocode(address, output="all")
  LatLong1 <- getfields(GoogleResults)
  
  #   Did we error?
  
  if (is.na(LatLong1$Type) |
      LatLong1$Type == "ZERO_RESULTS"){
          LatLong1$status <- "no result"
          return(LatLong1)
      }
  
  #   Are we within the city?
  
  if (!between(LatLong1$lat, HoustonBdy[2], HoustonBdy[4]) |
      !between(LatLong1$long, HoustonBdy[1], HoustonBdy[3])){
          LatLong1$status <- "outside boundary"
          return(LatLong1)
      }
  
  #   Is it a bogus location at center of long street?
  
  if (LatLong1$LocType == "GEOMETRIC_CENTER") { # bad location
          LatLong1$status <- "Road only, street number ignored"
          return(LatLong1)
  }
  
  # REALLY bogus location - don't want this
    
  if (LatLong1$LocType == "APPROXIMATE" ) { # bad location
          LatLong1$status <- "City only, street ignored"
          return(LatLong1)
  }
  
  #   Is the match name "close enough"?
  x <- unlist(strsplit(unlist(LatLong1$match_address), ","))
  utstreet <- trimws(sub("^[0-9]+", "", x[1]))
  if (tolower(street) != tolower(utstreet)){
          LatLong1$status <- "Names mismatch"
          return(LatLong1)
  }
  
  #   Now tweak the street number and get a new set
  #   unless LocType == "ROOFTOP"
  
  if (LatLong1$LocType != "ROOFTOP") { # interpolated location
      addrnumber <- str_extract(address, "^[0-9]+ ")
      addrnumber2 <- as.character(as.numeric(addrnumber)+15)
      address <- str_replace(address, addrnumber, addrnumber2)
      GoogleResults <- geocode(address, output="all")
      LatLong2 <- getfields(GoogleResults)
        
    #   Are the answers the same? If so, we have a problem
      distance <- dist(rbind(c(LatLong1$lat, LatLong1$long),
                        c(LatLong2$lat, LatLong2$long))) *
                        69*5280
      if (distance < 10){# could be almost anywhere, reject
          LatLong1$status <- paste("Distance =",as.character(distance))
          return(LatLong1)
      }
  }
  #   All the tests passed, successful return
        LatLong1$status <- "success"
        return(LatLong1)
  
}

```

##    And here we run google

```{r run google}

# re-edit addresses

#unmatched <- readRDS( "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

source("Edit_Addresses.R") # load in address edits

dict <- Makedict(dictionary)
#   test them first
testregex(unmatched, "Address", dict)
#   Apply
unmatched <- applyregex(unmatched, "Address", dict)

#    special cases - digits replace last 2 on address
special <- tribble(
  ~match, ~addr,
  "GREENWAY PLAZA DR", "03",
  "IRVINGTON BLVD",    "05",
  "CUMMINS ST",        "15",
  "N SAN JACINTO",     "15",
  "S HEIGHTS BLVD",    "15",
  "VERNON ST",         "15",
  "VISTA WOODS DR",    "15",
  "EAST",              "41",
  "CETTIPARK ST",      "10"
)

# Skip these, won't get them, this will speed things up

skips <- c("HOMELESS", "PO BOX", "POBOX", "ENTRANCE")

##########################################
##    next spin through data geocoding
##########################################

unmatched <- unmatched %>% mutate(GType=NA) # add new information column


geocodeQueryCheck()
begin <- 12000
#for (i in begin:nrow(unmatched)) {
for (i in begin:(begin+199)) {
#for (i in 10175:10175) {
  if (unmatched[i,]$status!="success"){ # only the redo's
    # skip hopeless cases
    if (any(str_detect(unmatched[i,]$Address, skips))){next()}
    # skip distance <10 cases
    if (unmatched[i,]$status=="Distance = 0"){next()}
    # skip GEOMETRIC_CENTER cases
    if(!is.na(unmatched[i,]$GType) &
        unmatched[i,]$GType == "GEOMETRIC_CENTER route") {next()}
    # only do selected cases
    #if (!any(str_detect(unmatched[i,]$Address, onlys))){next()}
    print(paste("--->",i,unmatched[i,1]))
    # Did I already succeed at this match somewhere?
    a <- unmatched %>% filter(Address == unmatched[i,]$Address,
                              status=="success" )
    if (nrow(a)>0){
      unmatched[i,4:10] <- a[1,4:10]
      print("found previous match")
      next
    }
    newaddr <- "30"
    if (grepl("FWY", unmatched[i,]$Address)){newaddr <- "15"}
    if(any(str_detect(unmatched[i,]$Address, special$match))){
      newaddr <- special[str_detect(unmatched[i,]$Address, special$match),]$addr
    }
    
    #   Call google
    
    latlong <- GetLatLongGoogle( unmatched[i,]$Address, newaddr)
    if (latlong$status=="success") {
      #print(paste("=======final=======",latlong[1,]))
      print(paste("=======success======="))
      unmatched[i,]$match_address  <- latlong$match_address
      unmatched[i,]$lat            <- latlong$lat
      unmatched[i,]$long           <- latlong$long
      unmatched[i,]$geocode_status <- "google"
      unmatched[i,]$status         <- latlong$status
      unmatched[i,]$GType          <- paste(latlong$LocType, latlong$Type)
    } else if (latlong$status=="Names mismatch"){
      print(paste("=======fail=======",latlong[1,]))
      unmatched[i,]$geocode_status <- "google fail"
      unmatched[i,]$status         <- latlong$status
      unmatched[i,]$GType          <- paste(latlong$LocType, latlong$Type)
      unmatched[i,]$match_address  <- latlong$match_address
    } else{
      print(paste("=======fail======="))
      unmatched[i,]$geocode_status <- "google fail"
      unmatched[i,]$status         <- latlong$status
      unmatched[i,]$GType          <- paste(latlong$LocType, latlong$Type)
      unmatched[i,]$match_address  <- latlong$match_address
    }
  }
}

saveRDS(unmatched, "~/Dropbox/CrimeStats/CensusGeoTable_progress.rds")

#   Percent of unique addresses found, and percent of total found

unmatched %>% 
  group_by(geocode_status) %>% 
  summarise(n=n())


```

```{r test google geocode}

addrs <- c("1300-1399 TULANE ST, HOUSTON, TX",
           "1700-1799 TULANE ST, HOUSTON, TX") 

for (i in 1:2) {
    print(paste("--->",i,addrs[i]))
    newaddr <- "30"
    if (grepl("FWY", addrs[i])){newaddr <- "15"}
    
    #   Call google
    
    latlong <- GetLatLongGoogle( addrs[i], newaddr)
    if (latlong$status=="success") {
      print(paste("=======final=======",latlong[1,]))
    } else {
      print(paste("=======fail=======",latlong[1,]))
    }
}


```

